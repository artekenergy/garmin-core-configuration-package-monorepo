import { createContext, useContext, useState, ReactNode, useEffect } from 'react';
import { validateSchema, type UISchema, type ValidationResult } from '@gcg/schema';
import { debug } from '../utils/debug';import { regenerateTabContent } from '../utils/tabGenerator';
import {
  validateAllChannelBindings,
  type ChannelValidationError,
} from '../utils/channelValidation';

/**
 * Hardware channel info extracted from hardware-config.json
 */
export interface HardwareChannel {
  id: string; // e.g., "core-01"
  label: string; // e.g., "Galley Lights"
  control: string; // Control type (allow any string from hardware config)
  icon?: string; // Icon path if specified
  source: 'core' | 'genesis' | 'lite'; // Which board
  channel: number; // Channel number on that board
  signals?: {
    toggle: number | null;
    momentary: number | null;
    dimmer: number | null;
  };
}

interface SchemaContextType {
  schema: UISchema | null;
  validationResult: ValidationResult | null;
  hardwareChannels: HardwareChannel[]; // Available channels from hardware config
  channelErrors: ChannelValidationError[]; // Channel binding validation errors
  updateSchema: (newSchema: UISchema) => void;
  loadSchema: (schemaData: unknown) => void;
  resetSchema: () => void;
  loadHardwareConfig: (hardwareConfigData: unknown) => void; // New method
}

const SchemaContext = createContext<SchemaContextType | undefined>(undefined);

const defaultSchema: UISchema = {
  schemaVersion: '0.1.0',
  metadata: {
    name: 'New HMI Configuration',
    version: '1.0.0',
    description: 'Created with Garmin Core Graphics Configurator',
    author: '',
    createdAt: new Date().toISOString(),
    updatedAt: new Date().toISOString(),
  },
  hardware: {
    systemType: 'core',
    outputs: [],
    halfBridgePairs: [],
    signalMap: {},
    genesisBoards: 0,
  },
  power: {
    dcCharging: {
      secondAlternator: false,
      orionXs: false,
    },
    solar: {
      enabled: false,
      primaryArray: false,
      auxiliaryArray: false,
    },
    batteryManagement: 'victron',
    acLegs: 2,
    multiplus: {
      l1: false,
      l2: false,
    },
  },
  hvac: {
    heating: {
      enabled: false,
      sources: { diesel: false, electric: false, engine: false },
      distribution: { floor: false, fans: false },
      hotWater: false,
      auxZone: false,
    },
    cooling: {
      enabled: false,
      brand: '',
    },
    ventilation: {
      enabled: false,
      fans: 1,
    },
  },
  plumbing: {
    enabled: false,
    monitoringSource: 'cerbo-gx',
    count: 1,
    tanks: [
      { type: 'fresh', name: '' },
    ],
  },
  accessories: {
    keypad: {
      enabled: false,
      count: 1,
      buttonsPerKeypad: 8,
    },
    awning: {
      enabled: false,
      light: false,
      controlType: 'rvc',
    },
    slides: {
      enabled: false,
      controlType: 'rvc',
      keypadSecured: false,
    },
    itcLighting: {
      enabled: false,
      modules: 0,
      zonesPerModule: 2,
    },
  },
  tabs: [
    {
      id: 'tab-home',
      title: 'Home',
      preset: 'home',
      enabled: false,
      sections: [
        {
          id: 'section-home-1',
          title: 'Quick Controls',
          enabled: false,
          components: [],
        },
        {
          id: 'section-home-2',
          title: 'Status',
          enabled: false,
          components: [],
        },
      ],
    },
    {
      id: 'tab-lighting',
      title: 'Lighting',
      preset: 'lighting',
      enabled: false,
      sections: [
        {
          id: 'section-lighting-interior',
          title: 'Interior Lights',
          enabled: false,
          components: [],
        },
        {
          id: 'section-lighting-exterior',
          title: 'Exterior Lights',
          enabled: false,
          components: [],
        },
      ],
    },
    {
      id: 'tab-power',
      title: 'Power',
      preset: 'power',
      enabled: false,
      sections: [
        {
          id: 'section-power',
          title: 'Power Status',
          enabled: false,
          components: [],
        },
      ],
    },
    {
      id: 'tab-hvac',
      title: 'HVAC',
      preset: 'hvac',
      enabled: false, // Disabled by default
      sections: [
        {
          id: 'section-climate',
          title: 'Climate Control',
          enabled: true,
          components: [],
        },
      ],
    },
    {
      id: 'tab-switching',
      title: 'Switching',
      preset: 'switching',
      enabled: false,
      sections: [
        {
          id: 'section-switches',
          title: 'Switches',
          enabled: false,
          components: [],
        },
      ],
    },
    {
      id: 'tab-plumbing',
      title: 'Plumbing',
      preset: 'plumbing',
      enabled: false, // Disabled by default
      sections: [
        {
          id: 'section-tanks',
          title: 'Tank Levels',
          enabled: true,
          components: [],
        },
      ],
    },
  ],
};

export function SchemaProvider({ children }: { children: ReactNode }) {
  const [schema, setSchema] = useState<UISchema | null>(() => {
    // Fix section IDs when loading the default schema
    return regenerateTabContent(defaultSchema);
  });
  const [validationResult, setValidationResult] = useState<ValidationResult | null>(null);
  const [hardwareChannels, setHardwareChannels] = useState<HardwareChannel[]>([]);
  const [channelErrors, setChannelErrors] = useState<ChannelValidationError[]>([]);

  // Debug helper: Expose schema to browser console for debugging
  useEffect(() => {
    if (typeof window !== 'undefined') {
      (window as any).__GCG_DEBUG__ = {
        schema,
        validationResult,
        hardwareChannels,
        channelErrors,
        downloadSchema: () => {
          if (!schema) {
            console.warn('No schema available');
            return;
          }
          const schemaJson = JSON.stringify(schema, null, 2);
          const dataBlob = new Blob([schemaJson], { type: 'application/json' });
          const url = URL.createObjectURL(dataBlob);
          const link = document.createElement('a');
          link.href = url;
          link.download = `debug-schema-${Date.now()}.json`;
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
          URL.revokeObjectURL(url);
          debug.log('✅ Schema downloaded!');
        },
        copySchemaToClipboard: async () => {
          if (!schema) {
            console.warn('No schema available');
            return;
          }
          try {
            const schemaJson = JSON.stringify(schema, null, 2);
            await navigator.clipboard.writeText(schemaJson);
            debug.log('✅ Schema copied to clipboard!');
          } catch (err) {
            console.error('❌ Failed to copy to clipboard:', err);
            debug.log('Schema JSON:', JSON.stringify(schema, null, 2));
          }
        },
        exportDOMSnapshot: () => {
          const snapshot = {
            timestamp: new Date().toISOString(),
            userAgent: navigator.userAgent,
            url: window.location.href,
            schema: schema,
            validationResult: validationResult,
            hardwareChannels: hardwareChannels,
            channelErrors: channelErrors,
            domSnapshot: {
              title: document.title,
              forms: Array.from(document.forms).map(form => ({
                name: form.name,
                action: form.action,
                method: form.method,
                elements: Array.from(form.elements).map(el => ({
                  name: (el as any).name,
                  type: (el as any).type,
                  value: (el as any).value,
                  checked: (el as any).checked
                }))
              })),
              localStorage: { ...localStorage },
              sessionStorage: { ...sessionStorage }
            }
          };
          
          const snapshotJson = JSON.stringify(snapshot, null, 2);
          const dataBlob = new Blob([snapshotJson], { type: 'application/json' });
          const url = URL.createObjectURL(dataBlob);
          const link = document.createElement('a');
          link.href = url;
          link.download = `dom-snapshot-${Date.now()}.json`;
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
          URL.revokeObjectURL(url);
          debug.log('✅ DOM snapshot downloaded!');
        }
      };
    }
  }, [schema, validationResult, hardwareChannels, channelErrors]);

  // Validate schema whenever it changes
  useEffect(() => {
    if (schema) {
      const result = validateSchema(schema);
      setValidationResult(result);
    } else {
      setValidationResult(null);
    }
  }, [schema]);

  // Validate channel bindings whenever schema or hardware channels change
  useEffect(() => {
    if (schema && hardwareChannels.length > 0) {
      const errors = validateAllChannelBindings(schema, hardwareChannels);
      setChannelErrors(errors);

      if (errors.length > 0) {
        console.warn(`⚠️ Found ${errors.length} channel binding errors:`, errors);
      } else {
        debug.log('✅ All channel bindings are valid');
      }
    } else {
      setChannelErrors([]);
    }
  }, [schema, hardwareChannels]);

  const updateSchema = (newSchema: UISchema) => {
    setSchema({
      ...newSchema,
      metadata: {
        ...newSchema.metadata,
        updatedAt: new Date().toISOString(),
      },
    });
  };

  const loadSchema = (schemaData: unknown) => {
    const result = validateSchema(schemaData);
    if (result.success) {
      // Fix section IDs when loading a schema
      const fixedSchema = regenerateTabContent(result.data);
      setSchema(fixedSchema);
    } else {
      // Even if invalid, fix section IDs and store it so user can see/fix errors
      const fixedSchema = regenerateTabContent(schemaData as UISchema);
      setSchema(fixedSchema);
    }
  };

  const resetSchema = () => {
    // Fix section IDs when resetting
    const fixedSchema = regenerateTabContent(defaultSchema);
    setSchema(fixedSchema);
  };

  /**
   * Load and parse hardware config to extract available channels
   */
  const loadHardwareConfig = (hardwareConfigData: unknown) => {
    try {
      // Basic validation
      if (
        !hardwareConfigData ||
        typeof hardwareConfigData !== 'object' ||
        !('outputs' in hardwareConfigData)
      ) {
        console.error('Invalid hardware config format');
        return;
      }

      const config = hardwareConfigData as {
        systemType?: string;
        outputs: Array<{
          id: string;
          label: string;
          control: string;
          icon?: string;
          source: string;
          channel: number;
          signals?: {
            toggle: number | null;
            momentary: number | null;
            dimmer: number | null;
          };
        }>;
      };

      // Extract channels from hardware config
      const channels: HardwareChannel[] = config.outputs.map((output) => ({
        id: output.id,
        label: output.label,
        control: output.control, // Keep as string
        icon: output.icon,
        source: output.source as 'core' | 'genesis' | 'lite',
        channel: output.channel,
        signals: output.signals,
      }));

      setHardwareChannels(channels);

      debug.log(`✅ Loaded ${channels.length} hardware channels from config`);
    } catch (error) {
      console.error('Failed to parse hardware config:', error);
    }
  };

  return (
    <SchemaContext.Provider
      value={{
        schema,
        validationResult,
        hardwareChannels,
        channelErrors,
        updateSchema,
        loadSchema,
        resetSchema,
        loadHardwareConfig,
      }}
    >
      {children}
    </SchemaContext.Provider>
  );
}

export function useSchema() {
  const context = useContext(SchemaContext);
  if (!context) {
    throw new Error('useSchema must be used within a SchemaProvider');
  }
  return context;
}
